<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Relationship Chart (Prototype)</title>
  <style>
    :root{
      --bg:#070A12;
      --panel:rgba(10,18,35,.72);
      --text:rgba(220,245,255,.92);
      --muted:rgba(220,245,255,.62);
      --accent:#7df9ff;
      --accent2:#b56bff;
      --danger:#ff3b6b;
      --ok:#7CFF7A;
    }
    html,body{height:100%; margin:0; background:
      radial-gradient(1200px 700px at 20% 10%, rgba(125,249,255,.12), transparent 55%),
      radial-gradient(900px 600px at 80% 20%, rgba(181,107,255,.10), transparent 55%),
      var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", Arial, sans-serif;
    }
    .wrap{position:relative; height:100%; overflow:hidden;}
    canvas{position:absolute; inset:0; width:100%; height:100%;}

    .hud{
      position:absolute; left:14px; top:14px; width:min(420px, calc(100% - 28px));
      background:var(--panel);
      border:1px solid rgba(125,249,255,.25);
      box-shadow: 0 0 0 1px rgba(181,107,255,.12), 0 14px 40px rgba(0,0,0,.45);
      border-radius:16px; padding:14px 14px 12px;
      backdrop-filter: blur(10px);
    }
    .title{display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.02em;}
    .badge{
      font-size:12px; padding:4px 8px; border-radius:999px;
      border:1px solid rgba(125,249,255,.35);
      color:var(--accent);
      background:rgba(125,249,255,.08);
    }
    .row{display:flex; gap:10px; margin-top:10px; flex-wrap:wrap;}
    .btn{
      cursor:pointer; user-select:none;
      font-size:12px; padding:8px 10px; border-radius:12px;
      border:1px solid rgba(125,249,255,.25);
      background:rgba(0,0,0,.22);
      color:var(--text);
      transition: transform .08s ease, border-color .12s ease, background .12s ease;
    }
    .btn:hover{transform: translateY(-1px); border-color: rgba(125,249,255,.5);}
    .btn:active{transform: translateY(0px);}
    .btn.on{border-color: rgba(124,255,122,.55); box-shadow:0 0 0 1px rgba(124,255,122,.15) inset;}
    .btn.danger{border-color: rgba(255,59,107,.35);}
    .btn.danger:hover{border-color: rgba(255,59,107,.7);}

    .search{margin-top:10px; display:flex; gap:8px; align-items:center;}
    input{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(125,249,255,.22);
      background:rgba(0,0,0,.22);
      color:var(--text);
      outline:none;
    }
    input::placeholder{color:rgba(220,245,255,.35)}
    .hint{margin-top:10px; color:var(--muted); font-size:12px; line-height:1.4;}

    .side{
      position:absolute; right:14px; top:14px;
      width:min(380px, calc(100% - 28px));
      background:var(--panel);
      border:1px solid rgba(181,107,255,.25);
      box-shadow: 0 0 0 1px rgba(125,249,255,.10), 0 14px 40px rgba(0,0,0,.45);
      border-radius:16px; padding:14px;
      backdrop-filter: blur(10px);
      display:none;
    }
    .side.show{display:block;}
    .side h2{margin:0 0 8px; font-size:16px;}
    .kv{display:grid; grid-template-columns: 96px 1fr; gap:6px 10px; font-size:12px; color:var(--muted);}
    .kv b{color:var(--text); font-weight:600;}
    .divider{height:1px; background:rgba(220,245,255,.12); margin:10px 0;}
    .mini{font-size:12px; color:var(--muted); line-height:1.45;}
    .tag{
      display:inline-flex; align-items:center; gap:6px;
      padding:4px 8px; border-radius:999px;
      border:1px solid rgba(220,245,255,.18);
      background:rgba(255,255,255,.05);
      color:var(--text);
      font-size:12px;
      margin-right:6px;
      margin-top:6px;
    }

    .scanlines{
      pointer-events:none;
      position:absolute; inset:0;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.03),
        rgba(255,255,255,.03) 1px,
        rgba(0,0,0,0) 3px,
        rgba(0,0,0,0) 6px
      );
      mix-blend-mode: overlay;
      opacity:.45;
    }
    .vignette{
      pointer-events:none;
      position:absolute; inset:-20%;
      background: radial-gradient(circle at 50% 40%, transparent 40%, rgba(0,0,0,.65) 78%);
      opacity:.9;
    }
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="c"></canvas>
  <div class="scanlines"></div>
  <div class="vignette"></div>

  <div class="hud">
    <div class="title">
      <span class="badge">PROTO</span>
      <div>RELATIONSHIP CHART / GAME HUD</div>
    </div>

    <div class="row">
      <div class="btn on" id="btnPhysics">Physics</div>
      <div class="btn on" id="btnGlow">Glow</div>
      <div class="btn on" id="btnSfx">SFX</div>
      <div class="btn" id="btnCenter">Recenter</div>
      <div class="btn danger" id="btnShuffle">Shuffle</div>
    </div>

    <div class="search">
      <input id="q" placeholder="キャラ名で検索（例：菜々 / Mona）" />
    </div>
    <div class="hint">
      ・ノードをクリック → 右上に詳細パネル<br/>
      ・エッジに近づくと関係タイプ/強度を表示<br/>
      ・同階層に data.json があれば自動で読み込み（無ければ内蔵ダミーで起動）
    </div>
  </div>

  <div class="side" id="side">
    <h2 id="sideTitle">—</h2>
    <div class="kv" id="sideKv"></div>
    <div class="divider"></div>
    <div class="mini" id="sideBody"></div>
  </div>
</div>

<script>
/** =========================
 *  Data loading
 * ========================= */
async function loadData(){
  // 同階層の data.json を読む（無いなら例外→フォールバック）
  const res = await fetch('./data.json', {cache:'no-store'});
  if(!res.ok) throw new Error('data.json not found');
  return await res.json();
}

/** =========================
 *  Tiny SFX (WebAudio)
 * ========================= */
class Sfx {
  constructor(){
    this.enabled = true;
    this.ctx = null;
    this.master = null;
  }
  ensure(){
    if(this.ctx) return;
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const master = ctx.createGain();
    master.gain.value = 0.25;
    master.connect(ctx.destination);
    this.ctx = ctx; this.master = master;
  }
  beep(freq=880, dur=0.05, type='square', gain=0.8){
    if(!this.enabled) return;
    this.ensure();
    const t0 = this.ctx.currentTime;
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.008);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g); g.connect(this.master);
    o.start(t0);
    o.stop(t0 + dur + 0.01);
  }
  click(){
    this.beep(740, 0.04, 'square', 0.7);
    this.beep(1480, 0.03, 'triangle', 0.45);
  }
  hover(){ this.beep(1040, 0.025, 'triangle', 0.35); }
  error(){ this.beep(220, 0.08, 'sawtooth', 0.55); }
}
const sfx = new Sfx();

/** =========================
 *  Canvas graph
 * ========================= */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W=0,H=0, DPR=1;

function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = canvas.clientWidth;
  H = canvas.clientHeight;
  canvas.width = Math.floor(W * DPR);
  canvas.height = Math.floor(H * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resize);

function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; }

function colorForType(t){
  switch(String(t||'').trim()){
    case 'ライバル': return 'rgba(125,249,255,.85)';
    case '敵対': return 'rgba(255,59,107,.85)';
    case '因縁': return 'rgba(255,187,80,.85)';
    case '先輩後輩': return 'rgba(120,170,255,.85)';
    case '同僚・同期': return 'rgba(170,255,245,.75)';
    case '友情': return 'rgba(124,255,122,.85)';
    case '師弟': return 'rgba(181,107,255,.85)';
    case 'グループ': return 'rgba(220,245,255,.65)';
    default: return 'rgba(220,245,255,.55)';
  }
}
function weightForStars(s){
  const m = String(s||'').match(/★/g);
  return m ? m.length : 2;
}

let nodes=[], edges=[];
let physics = true, glow = true;

const state = { mx:0, my:0, hoverNode:null, hoverEdge:null, dragNode:null, dragging:false, filterText:'' };

function step(){
  if(!physics) return;
  const rep = 1600;
  for(let i=0;i<nodes.length;i++){
    const a = nodes[i];
    for(let j=i+1;j<nodes.length;j++){
      const b = nodes[j];
      const dx = a.x - b.x, dy = a.y - b.y;
      let d2 = dx*dx + dy*dy + 0.01;
      const f = rep / d2;
      const fx = (dx/Math.sqrt(d2)) * f;
      const fy = (dy/Math.sqrt(d2)) * f;
      a.vx += fx; a.vy += fy;
      b.vx -= fx; b.vy -= fy;
    }
  }
  for(const e of edges){
    const a = e.a, b = e.b;
    const dx = b.x - a.x, dy = b.y - a.y;
    const d = Math.sqrt(dx*dx + dy*dy) + 0.001;
    const diff = (d - e.len);
    const fx = (dx/d) * (diff * e.k);
    const fy = (dy/d) * (diff * e.k);
    a.vx += fx; a.vy += fy;
    b.vx -= fx; b.vy -= fy;
  }
  const cx = W*0.56, cy = H*0.54;
  for(const n of nodes){
    n.vx += (cx - n.x) * 0.0008;
    n.vy += (cy - n.y) * 0.0008;
    n.vx *= 0.82;
    n.vy *= 0.82;
    if(state.dragNode === n && state.dragging){
      n.x = state.mx; n.y = state.my;
      n.vx = 0; n.vy = 0;
    } else {
      n.x += n.vx;
      n.y += n.vy;
    }
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);

  // grid
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.strokeStyle = 'rgba(125,249,255,.20)';
  ctx.lineWidth = 1;
  const g = 42;
  for(let x= (W%g); x<W; x+=g){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y= (H%g); y<H; y+=g){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.restore();

  // edges
  for(const e of edges){
    if(!e.visible) continue;
    const col = colorForType(e.type);
    const w = 1 + e.str*0.35;

    if(glow){
      ctx.save();
      ctx.strokeStyle = col;
      ctx.globalAlpha = 0.22;
      ctx.lineWidth = w*6;
      ctx.beginPath(); ctx.moveTo(e.a.x,e.a.y); ctx.lineTo(e.b.x,e.b.y); ctx.stroke();
      ctx.restore();
    }

    ctx.save();
    ctx.strokeStyle = col;
    ctx.globalAlpha = 0.65;
    ctx.lineWidth = w;
    ctx.beginPath(); ctx.moveTo(e.a.x,e.a.y); ctx.lineTo(e.b.x,e.b.y); ctx.stroke();
    ctx.restore();
  }

  // nodes
  for(const n of nodes){
    if(!n.visible) continue;
    const r = n.r;
    const isHover = (state.hoverNode === n);
    const alpha = isHover ? 1.0 : 0.92;

    if(glow){
      ctx.save();
      ctx.fillStyle = 'rgba(125,249,255,.16)';
      ctx.globalAlpha = isHover ? 0.85 : 0.55;
      ctx.beginPath(); ctx.arc(n.x,n.y,r*2.2,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }

    ctx.save();
    ctx.fillStyle = n.color;
    ctx.globalAlpha = alpha;
    ctx.beginPath(); ctx.arc(n.x,n.y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.strokeStyle = 'rgba(220,245,255,.55)';
    ctx.lineWidth = isHover ? 2 : 1;
    ctx.beginPath(); ctx.arc(n.x,n.y,r,0,Math.PI*2); ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.font = (isHover ? '700 14px' : '600 13px') + ' ui-sans-serif, system-ui, -apple-system, "Noto Sans JP", "Yu Gothic"';
    ctx.fillStyle = 'rgba(220,245,255,.92)';
    ctx.shadowColor = 'rgba(0,0,0,.55)';
    ctx.shadowBlur = 8;
    ctx.fillText(n.name, n.x + r + 10, n.y + 5);
    ctx.restore();
  }

  // edge tooltip
  if(state.hoverEdge){
    const e = state.hoverEdge;
    const mx = state.mx, my = state.my;
    const text = `${e.type || '関係'} / ${e.strStars || ''}  ${e.label || ''}`.trim();
    const pad = 10;
    ctx.save();
    ctx.font = '600 12px ui-sans-serif, system-ui, -apple-system, "Noto Sans JP"';
    const tw = ctx.measureText(text).width;
    const bw = tw + pad*2;
    const bh = 30;
    const x = clamp(mx + 16, 12, W - bw - 12);
    const y = clamp(my + 16, 12, H - bh - 12);
    ctx.fillStyle = 'rgba(10,18,35,.85)';
    ctx.strokeStyle = 'rgba(125,249,255,.28)';
    ctx.lineWidth = 1;
    roundRect(ctx, x, y, bw, bh, 10);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = 'rgba(220,245,255,.92)';
    ctx.fillText(text, x + pad, y + 19);
    ctx.restore();
  }
}

function roundRect(ctx,x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

function pickNode(x,y){
  for(let i=nodes.length-1;i>=0;i--){
    const n = nodes[i];
    if(!n.visible) continue;
    if(dist2(x,y,n.x,n.y) <= (n.r*n.r)) return n;
  }
  return null;
}

function pointToSegmentDistance(px,py, ax,ay, bx,by){
  const abx = bx-ax, aby = by-ay;
  const apx = px-ax, apy = py-ay;
  const ab2 = abx*abx + aby*aby + 0.0001;
  let t = (apx*abx + apy*aby)/ab2;
  t = clamp(t, 0, 1);
  const cx = ax + abx*t, cy = ay + aby*t;
  const dx = px-cx, dy = py-cy;
  return Math.sqrt(dx*dx + dy*dy);
}

function pickEdge(x,y){
  let best=null, bestD=9999;
  for(const e of edges){
    if(!e.visible) continue;
    const d = pointToSegmentDistance(x,y, e.a.x,e.a.y, e.b.x,e.b.y);
    if(d < 10 && d < bestD){ best = e; bestD = d; }
  }
  return best;
}

function applyFilter(){
  const q = state.filterText.trim().toLowerCase();
  if(!q){
    for(const n of nodes) n.visible = true;
    for(const e of edges) e.visible = true;
    return;
  }
  for(const n of nodes) n.visible = n.name.toLowerCase().includes(q);
  for(const e of edges) e.visible = e.a.visible || e.b.visible;
}

function openSideForNode(n){
  const side = document.getElementById('side');
  const title = document.getElementById('sideTitle');
  const kv = document.getElementById('sideKv');
  const body = document.getElementById('sideBody');

  title.textContent = n.name;
  kv.innerHTML = '';
  const add = (k,v)=>{
    const d1 = document.createElement('div'); d1.textContent = k;
    const d2 = document.createElement('div'); d2.innerHTML = '<b>' + (v ?? '—') + '</b>';
    kv.appendChild(d1); kv.appendChild(d2);
  };
  add('シリーズ', n.series || '—');
  add('タイプ', n.archetype || '—');
  add('メモ', n.note || '—');

  const rel = edges.filter(e => e.a===n || e.b===n).slice(0, 10);
  const lines = rel.map(e=>{
    const other = (e.a===n) ? e.b : e.a;
    return `<span class="tag" style="border-color:${colorForType(e.type)}">${e.type||'関係'} ${e.strStars||''} → ${other.name}</span>`;
  }).join('');

  body.innerHTML = `
    <div class="mini">${(n.desc || '（説明なし）')}</div>
    <div style="margin-top:10px">${lines || '<span class="mini">関連がまだ登録されていません</span>'}</div>
  `;
  side.classList.add('show');
}

function normalizeData(raw){
  const id2node = new Map();
  nodes = raw.nodes.map((n, idx)=>{
    const node = {
      id: n.id ?? String(idx),
      name: n.name ?? 'Unnamed',
      series: n.series ?? '',
      archetype: n.archetype ?? '',
      note: n.note ?? '',
      desc: n.desc ?? '',
      x: (W*0.35) + (Math.random()-0.5)*220,
      y: (H*0.55) + (Math.random()-0.5)*220,
      vx: 0, vy: 0,
      r: 12 + (n.rank ?? 0)*1.2,
      color: n.color ?? 'rgba(125,249,255,.85)',
      visible: true
    };
    id2node.set(node.id, node);
    return node;
  });

  edges = raw.edges.map((e)=>{
    const a = id2node.get(e.from);
    const b = id2node.get(e.to);
    const str = weightForStars(e.strength);
    return {
      a,b,
      type: e.type ?? '',
      label: e.label ?? '',
      str,
      strStars: e.strength ?? '',
      len: 120 + (5-str)*22,
      k: 0.0018 + str*0.00035,
      visible: true
    };
  }).filter(e => e.a && e.b);

  applyFilter();
}

function shufflePositions(){
  for(const n of nodes){
    n.x = (W*0.56) + (Math.random()-0.5)*420;
    n.y = (H*0.54) + (Math.random()-0.5)*360;
    n.vx = 0; n.vy = 0;
  }
}
function recenter(){
  const cx=W*0.56, cy=H*0.54;
  for(const n of nodes){
    n.x = cx + (Math.random()-0.5)*280;
    n.y = cy + (Math.random()-0.5)*240;
  }
}

function bindUI(){
  const btnPhysics = document.getElementById('btnPhysics');
  const btnGlow = document.getElementById('btnGlow');
  const btnSfx = document.getElementById('btnSfx');
  const btnCenter = document.getElementById('btnCenter');
  const btnShuffle = document.getElementById('btnShuffle');
  const q = document.getElementById('q');

  btnPhysics.onclick = () => { physics = !physics; btnPhysics.classList.toggle('on', physics); sfx.click(); };
  btnGlow.onclick = () => { glow = !glow; btnGlow.classList.toggle('on', glow); sfx.click(); };
  btnSfx.onclick = () => {
    sfx.enabled = !sfx.enabled;
    btnSfx.classList.toggle('on', sfx.enabled);
    if(sfx.enabled) sfx.click();
  };
  btnCenter.onclick = () => { recenter(); sfx.click(); };
  btnShuffle.onclick = () => { shufflePositions(); sfx.click(); };

  q.addEventListener('input', ()=>{ state.filterText = q.value; applyFilter(); });

  canvas.addEventListener('pointermove', (ev)=>{
    const r = canvas.getBoundingClientRect();
    state.mx = (ev.clientX - r.left);
    state.my = (ev.clientY - r.top);
  });

  canvas.addEventListener('pointerdown', (ev)=>{
    // mobile: unlock audio on first gesture
    sfx.ensure();

    const n = pickNode(state.mx, state.my);
    if(n){
      state.dragNode = n;
      state.dragging = true;
      sfx.click();
      openSideForNode(n);
    } else {
      const e = pickEdge(state.mx, state.my);
      if(e){ sfx.click(); }
      else { document.getElementById('side').classList.remove('show'); }
    }
    canvas.setPointerCapture(ev.pointerId);
  });

  canvas.addEventListener('pointerup', (ev)=>{
    state.dragging = false;
    state.dragNode = null;
    try{ canvas.releasePointerCapture(ev.pointerId); }catch(_){}
  });
}

function loop(){
  step();
  const hn = pickNode(state.mx, state.my);
  const he = hn ? null : pickEdge(state.mx, state.my);
  if(hn !== state.hoverNode){
    state.hoverNode = hn;
    if(hn) sfx.hover();
  }
  state.hoverEdge = he;
  draw();
  requestAnimationFrame(loop);
}

(async function main(){
  resize();
  bindUI();

  try{
    const raw = await loadData();
    normalizeData(raw);
  }catch(err){
    console.warn(err);
    // fallback demo data (見栄え用)
    normalizeData({
      nodes: [
        {id:'n1', name:'倉見 菜々', series:'看護婦MIX', archetype:'冷静系', desc:'（data.json が無くても動作する内蔵デモ）', color:'rgba(125,249,255,.85)', rank:2},
        {id:'n2', name:'早川 モナ', series:'看護婦MIX', archetype:'強気', desc:'ダミー', color:'rgba(181,107,255,.85)', rank:3},
        {id:'n3', name:'稲木 えみり', series:'OLプロレス', archetype:'王道', desc:'ダミー', color:'rgba(124,255,122,.85)', rank:1},
        {id:'n4', name:'薬師寺 乙世', series:'OLプロレス', archetype:'お嬢様ヒール', desc:'ダミー', color:'rgba(255,59,107,.85)', rank:4}
      ],
      edges: [
        {from:'n1', to:'n2', type:'ライバル', strength:'★★★★', label:'口喧嘩→乱闘'},
        {from:'n3', to:'n4', type:'敵対', strength:'★★★★★', label:'金とコネの強制試合'},
        {from:'n2', to:'n4', type:'因縁', strength:'★★★', label:'過去の遺恨'}
      ]
    });
  }

  recenter();
  loop();
})();
</script>
</body>
</html>
